{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Series of labs and instructions to introduce you to containers, Github Action and Azure Container Apps. Description \u00b6 The goal is to deploy a frontend application and an API packaged into Docker containers, containers pushed into Azure Container Registry and deployed into Azure Container Apps automatically each time we push new change into our github repository. Agenda \u00b6 Lab 0 Pre-work - Install Docker Lab 1 Lab 1 - Build and push our containers to Azure Container Registry Lab 2 Lab 2 - Deploy our app using Azure Container Apps Lab 3 Lab 3 - Automate app building and deployment using Github Action to Azure Container Apps Pre-requirements \u00b6 For this workshop you must have: Docker A Github Account An Azure Account Fork the current repository inside your Github account Technology Used \u00b6 Docker CLI Docker Compose Github Actions Azure Container Apps Application to deploy \u00b6 The demo app runs across two containers: words - a Java REST API which serves words read from a static list web - a Go web application which calls the API and builds words into sentences Run the application locally \u00b6 You can start the application using docker compose: docker compose up -d and test the application inside your browser on http://localhost:8080 .","title":"About the workshop"},{"location":"#introduction","text":"Series of labs and instructions to introduce you to containers, Github Action and Azure Container Apps.","title":"Introduction"},{"location":"#description","text":"The goal is to deploy a frontend application and an API packaged into Docker containers, containers pushed into Azure Container Registry and deployed into Azure Container Apps automatically each time we push new change into our github repository.","title":"Description"},{"location":"#agenda","text":"Lab 0 Pre-work - Install Docker Lab 1 Lab 1 - Build and push our containers to Azure Container Registry Lab 2 Lab 2 - Deploy our app using Azure Container Apps Lab 3 Lab 3 - Automate app building and deployment using Github Action to Azure Container Apps","title":"Agenda"},{"location":"#pre-requirements","text":"For this workshop you must have: Docker A Github Account An Azure Account Fork the current repository inside your Github account","title":"Pre-requirements"},{"location":"#technology-used","text":"Docker CLI Docker Compose Github Actions Azure Container Apps","title":"Technology Used"},{"location":"#application-to-deploy","text":"The demo app runs across two containers: words - a Java REST API which serves words read from a static list web - a Go web application which calls the API and builds words into sentences","title":"Application to deploy"},{"location":"#run-the-application-locally","text":"You can start the application using docker compose: docker compose up -d and test the application inside your browser on http://localhost:8080 .","title":"Run the application locally"},{"location":"lab-0/","text":"Lab 0 - Install Docker \u00b6 Overview \u00b6 In this lab, you will install docker. We will be using docker throughout the rest of the labs. Prerequisites \u00b6 None Optional: Install Docker Desktop \u00b6 Navigate to Get Docker , Select the option for your operating system or platform: Docker Desktop for Mac Docker Desktop for Windows Docker for Linux On this page you will find the installation for your operating systems. For example, if you are using a Mac, select \"MacOS\", to find the installation for the Mac platform. Summary \u00b6 By installing Docker, or alternatively, familiarizing yourself with Play with Docker , you are ready to complete the remaining labs in this course.","title":"Pre-work - Install Docker"},{"location":"lab-0/#lab-0-install-docker","text":"","title":"Lab 0 - Install Docker"},{"location":"lab-0/#overview","text":"In this lab, you will install docker. We will be using docker throughout the rest of the labs.","title":"Overview"},{"location":"lab-0/#prerequisites","text":"None","title":"Prerequisites"},{"location":"lab-0/#optional-install-docker-desktop","text":"Navigate to Get Docker , Select the option for your operating system or platform: Docker Desktop for Mac Docker Desktop for Windows Docker for Linux On this page you will find the installation for your operating systems. For example, if you are using a Mac, select \"MacOS\", to find the installation for the Mac platform.","title":"Optional: Install Docker Desktop"},{"location":"lab-0/#summary","text":"By installing Docker, or alternatively, familiarizing yourself with Play with Docker , you are ready to complete the remaining labs in this course.","title":"Summary"},{"location":"lab-1/","text":"Lab 1 - Build and Push Containers to Azure Container Registry \u00b6 The first step will be to create a Docker Registry, we will use Azure Container Registry for that. Create an Azure Container Registry \u00b6 Resource Group \u00b6 If needed, a new Resource Group can be created. It is recommended to create a new resource group for this tutorial, after which cleaning up will be easier. In Azure Portal's Resource groups , create a new resource group under your subscription. Container Registry \u00b6 In Azure Portal, create a new registry. You have many way of creating a ressource in Azure Portal On the top left menu \u00b6 In a Ressource Group \u00b6 In the pannel of the product you want to create \u00b6 Creating the registry \u00b6 Now, choose your subscription, ressource group, a name and a location. For the SKU, choose Basic as we do not need more for this workshop. After the registry is created, in that registry's Settings > Access Key, enable Admin user . This may not always be adviseable, but this enables the manual deployment in the lab-2 tutorial. Note: The Access Keys method should be replaced by using a service principal when possible as it's not the most secure way to connect to the registry. Also, the key in the screenshot are no more valid, if you share a key, you can rotate it to invalidate it ;-) Build and Push the Containers \u00b6 This step builds the two applications locally: docker build -t <registry-name>.azurecr.io/words:1.0.0 ./words docker build -t <registry-name>.azurecr.io/web:1.0.0 ./web Then the following will log into Azure, and push the containers. During the login, use the registry's admin user's name and password from the previous step. docker login <registry-name>.azurecr.io docker push <registry-name>.azurecr.io/words:1.0.0 docker push <registry-name>.azurecr.io/web:1.0.0 Finally, in the registry's Services > Repositories, validate that the two Docker images were pushed successfully. Summary \u00b6 In this step, we created a private docker registry, built two docker images and pushed them into the cloud. Note on public and private registries: When a project contains private or sensitive data, it is important to use a private registry. Other projects, such as open-source applications, may be pushed to public registries so that everyone can pull them. Docker Hub is a popular service that offers both public and private registries.","title":"Lab 1 - Build and push our containers to Azure Container Registry"},{"location":"lab-1/#lab-1-build-and-push-containers-to-azure-container-registry","text":"The first step will be to create a Docker Registry, we will use Azure Container Registry for that.","title":"Lab 1 - Build and Push Containers to Azure Container Registry"},{"location":"lab-1/#create-an-azure-container-registry","text":"","title":"Create an Azure Container Registry"},{"location":"lab-1/#resource-group","text":"If needed, a new Resource Group can be created. It is recommended to create a new resource group for this tutorial, after which cleaning up will be easier. In Azure Portal's Resource groups , create a new resource group under your subscription.","title":"Resource Group"},{"location":"lab-1/#container-registry","text":"In Azure Portal, create a new registry. You have many way of creating a ressource in Azure Portal","title":"Container Registry"},{"location":"lab-1/#on-the-top-left-menu","text":"","title":"On the top left menu"},{"location":"lab-1/#in-a-ressource-group","text":"","title":"In a Ressource Group"},{"location":"lab-1/#in-the-pannel-of-the-product-you-want-to-create","text":"","title":"In the pannel of the product you want to create"},{"location":"lab-1/#creating-the-registry","text":"Now, choose your subscription, ressource group, a name and a location. For the SKU, choose Basic as we do not need more for this workshop. After the registry is created, in that registry's Settings > Access Key, enable Admin user . This may not always be adviseable, but this enables the manual deployment in the lab-2 tutorial. Note: The Access Keys method should be replaced by using a service principal when possible as it's not the most secure way to connect to the registry. Also, the key in the screenshot are no more valid, if you share a key, you can rotate it to invalidate it ;-)","title":"Creating the registry"},{"location":"lab-1/#build-and-push-the-containers","text":"This step builds the two applications locally: docker build -t <registry-name>.azurecr.io/words:1.0.0 ./words docker build -t <registry-name>.azurecr.io/web:1.0.0 ./web Then the following will log into Azure, and push the containers. During the login, use the registry's admin user's name and password from the previous step. docker login <registry-name>.azurecr.io docker push <registry-name>.azurecr.io/words:1.0.0 docker push <registry-name>.azurecr.io/web:1.0.0 Finally, in the registry's Services > Repositories, validate that the two Docker images were pushed successfully.","title":"Build and Push the Containers"},{"location":"lab-1/#summary","text":"In this step, we created a private docker registry, built two docker images and pushed them into the cloud. Note on public and private registries: When a project contains private or sensitive data, it is important to use a private registry. Other projects, such as open-source applications, may be pushed to public registries so that everyone can pull them. Docker Hub is a popular service that offers both public and private registries.","title":"Summary"},{"location":"lab-2/","text":"Lab 2 - Deploy Applications using Azure Container Apps \u00b6 The demo application will be manually deployed in this step. Create a Container App \u00b6 The demo app requires two containers: a back-end, words , and a front-end, web . words:1.0.0 \u00b6 In Azure Portal's Container Apps , create a new application. In the Basics section, name the application words . A new container app environment must also be created. In the App settings section, uncheck the Use quickstart image checkbox, name the container words , and select your words:1.0.0 image from the registry. Enable the HTTP ingress, accepting traffic from anywhere, and set the port to 8080 . After the application is deployed, in its Overview, visit the application's URL, appending a /verbs at the end of the path. This should result in a JSON with a word attribute. web:1.0.0 \u00b6 Back in Azure Portal's Container Apps , create another new application. In the Basics section, name the application web , and select the same container app environment as the one that was created in the previous step. In the App settings section, uncheck the Use quickstart image checkbox, name the container web , and select your web:1.0.0 image from the registry. Enable the HTTP ingress, accepting traffic from anywhere, and set the port to 80 . After the application is deployed, in its Application > Containers, edit the container, click on the web container, and add an environment variable WORD_API_URL with value set to the words 's application's URL without the trailing / . After the web application is redeployed, visit its application URL. Lego blocks should appear on screen with words on them. Summary \u00b6 In this step, we created two container apps based on the images that were previously built.","title":"Lab 2 - Deploy our app using Azure Container Apps"},{"location":"lab-2/#lab-2-deploy-applications-using-azure-container-apps","text":"The demo application will be manually deployed in this step.","title":"Lab 2 - Deploy Applications using Azure Container Apps"},{"location":"lab-2/#create-a-container-app","text":"The demo app requires two containers: a back-end, words , and a front-end, web .","title":"Create a Container App"},{"location":"lab-2/#words100","text":"In Azure Portal's Container Apps , create a new application. In the Basics section, name the application words . A new container app environment must also be created. In the App settings section, uncheck the Use quickstart image checkbox, name the container words , and select your words:1.0.0 image from the registry. Enable the HTTP ingress, accepting traffic from anywhere, and set the port to 8080 . After the application is deployed, in its Overview, visit the application's URL, appending a /verbs at the end of the path. This should result in a JSON with a word attribute.","title":"words:1.0.0"},{"location":"lab-2/#web100","text":"Back in Azure Portal's Container Apps , create another new application. In the Basics section, name the application web , and select the same container app environment as the one that was created in the previous step. In the App settings section, uncheck the Use quickstart image checkbox, name the container web , and select your web:1.0.0 image from the registry. Enable the HTTP ingress, accepting traffic from anywhere, and set the port to 80 . After the application is deployed, in its Application > Containers, edit the container, click on the web container, and add an environment variable WORD_API_URL with value set to the words 's application's URL without the trailing / . After the web application is redeployed, visit its application URL. Lego blocks should appear on screen with words on them.","title":"web:1.0.0"},{"location":"lab-2/#summary","text":"In this step, we created two container apps based on the images that were previously built.","title":"Summary"},{"location":"lab-3/","text":"Lab 3 - Automate Build and Deployment using Github Action to Azure Container Apps \u00b6 The demo application will be deployed automatically using GitHub actions in this step. Create a Service Principal for GitHub \u00b6 Instead of the main Azure account, it is recommended to create a Service Principal , which will be used by GitHub to connect to Azure. The following will describe the steps necessary to create that service principal, and grant it the Contributor role at the resource group level. This role will be inherited by all resources under the resource group. Usually, the permissions granted would be more fine-grained. For example, the service principal would instead have the AcrPush role in the registry itself, but granting a wide-scoped role is easier during a demo. From the Terminal \u00b6 Using the az command, create a service principal: az ad sp create-for-rbac \\ --name \"github-bot\" \\ --role \"contributor\" \\ --scopes /subscriptions/c235daef-a49b-4feb-b432-9ea0b7cbbc6b/resourceGroups/064b73c3 The output will contain the service principal's ID ( appId ) and its password. Take note of them. From Azure Portal \u00b6 In Azure Portal's App registrations , create a new registration. Then, in that service principal's Manage > Certificates and secrets, create a new client secret, and take note of the generated secret value. In Azure Portal's Resource groups , select the resource group used for this demo. In Access Control (IAM), add a new role assignment with the Contributor role to the service principal created earlier. Add GitHub Secrets \u00b6 In your GitHub repository, go to Settings > Secrets, and add the following Action secrets: AZURE_CLIENT_ID : the Application (client) ID AZURE_CLIENT_SECRET : the generated secret value AZURE_CREDENTIALS : a JSON with the following value (placeholders replaced with actual values): { \"tenantId\" : \"<Tenant ID>\" , \"subscriptionId\" : \"<Subscription ID>\" , \"clientId\" : \"<Service Principal ID>\" , \"clientSecret\" : \"<Service Principal Secret>\" , \"resourceManagerEndpointUrl\" : \"https://management.azure.com/\" } While you are in the GitHub interface, visit the Actions section. If prompted, enable GitHub workflows, otherwise the next step will not trigger any actions. Add Github Actions \u00b6 The azure-deploy.yml file contains the GitHub workflow that is triggered when the main branch is pushed. Fill the jobs.deploy.env variables with their respective values: DOCKER_REGISTRY : The container registry's name, followed by .azurecr.io AZURE_RESOURCE_GROUP_NAME : The resource group's name AZURE_APP_NAME_WORDS : The container app's name for the Words application AZURE_APP_NAME_WEB : The container app's name for the Web application Now, create a directory for the Github Action: mkdir -p .github/workflows And copy or move the github action into it: mv azure-deploy.yml .github/workflows/ Push GitHub Workflow \u00b6 The changes to the GitHub workflow can now be commited and pushed to the remote repository. The workflow should start automatically, and can be found in the Actions section. Make a change in the web application \u00b6 For example, you can edit the title of the page. Open the web/static/index.html file and change <title>Global Azure 2022</title> for adding your name. Commit and push your change and check if the web application build and deploy. Once the Github Action finish, check your application to validate the change. Summary \u00b6 We created a limited account that could interact with our docker registry and our container applications. After that, we built and deployed our application only when they have some changes. You have now a full Continuous Deployment Pipeline running into Github!","title":"Lab 3 - Automate app building and deployment using Github Action to Azure Container Apps"},{"location":"lab-3/#lab-3-automate-build-and-deployment-using-github-action-to-azure-container-apps","text":"The demo application will be deployed automatically using GitHub actions in this step.","title":"Lab 3 - Automate Build and Deployment using Github Action to Azure Container Apps"},{"location":"lab-3/#create-a-service-principal-for-github","text":"Instead of the main Azure account, it is recommended to create a Service Principal , which will be used by GitHub to connect to Azure. The following will describe the steps necessary to create that service principal, and grant it the Contributor role at the resource group level. This role will be inherited by all resources under the resource group. Usually, the permissions granted would be more fine-grained. For example, the service principal would instead have the AcrPush role in the registry itself, but granting a wide-scoped role is easier during a demo.","title":"Create a Service Principal for GitHub"},{"location":"lab-3/#from-the-terminal","text":"Using the az command, create a service principal: az ad sp create-for-rbac \\ --name \"github-bot\" \\ --role \"contributor\" \\ --scopes /subscriptions/c235daef-a49b-4feb-b432-9ea0b7cbbc6b/resourceGroups/064b73c3 The output will contain the service principal's ID ( appId ) and its password. Take note of them.","title":"From the Terminal"},{"location":"lab-3/#from-azure-portal","text":"In Azure Portal's App registrations , create a new registration. Then, in that service principal's Manage > Certificates and secrets, create a new client secret, and take note of the generated secret value. In Azure Portal's Resource groups , select the resource group used for this demo. In Access Control (IAM), add a new role assignment with the Contributor role to the service principal created earlier.","title":"From Azure Portal"},{"location":"lab-3/#add-github-secrets","text":"In your GitHub repository, go to Settings > Secrets, and add the following Action secrets: AZURE_CLIENT_ID : the Application (client) ID AZURE_CLIENT_SECRET : the generated secret value AZURE_CREDENTIALS : a JSON with the following value (placeholders replaced with actual values): { \"tenantId\" : \"<Tenant ID>\" , \"subscriptionId\" : \"<Subscription ID>\" , \"clientId\" : \"<Service Principal ID>\" , \"clientSecret\" : \"<Service Principal Secret>\" , \"resourceManagerEndpointUrl\" : \"https://management.azure.com/\" } While you are in the GitHub interface, visit the Actions section. If prompted, enable GitHub workflows, otherwise the next step will not trigger any actions.","title":"Add GitHub Secrets"},{"location":"lab-3/#add-github-actions","text":"The azure-deploy.yml file contains the GitHub workflow that is triggered when the main branch is pushed. Fill the jobs.deploy.env variables with their respective values: DOCKER_REGISTRY : The container registry's name, followed by .azurecr.io AZURE_RESOURCE_GROUP_NAME : The resource group's name AZURE_APP_NAME_WORDS : The container app's name for the Words application AZURE_APP_NAME_WEB : The container app's name for the Web application Now, create a directory for the Github Action: mkdir -p .github/workflows And copy or move the github action into it: mv azure-deploy.yml .github/workflows/","title":"Add Github Actions"},{"location":"lab-3/#push-github-workflow","text":"The changes to the GitHub workflow can now be commited and pushed to the remote repository. The workflow should start automatically, and can be found in the Actions section.","title":"Push GitHub Workflow"},{"location":"lab-3/#make-a-change-in-the-web-application","text":"For example, you can edit the title of the page. Open the web/static/index.html file and change <title>Global Azure 2022</title> for adding your name. Commit and push your change and check if the web application build and deploy. Once the Github Action finish, check your application to validate the change.","title":"Make a change in the web application"},{"location":"lab-3/#summary","text":"We created a limited account that could interact with our docker registry and our container applications. After that, we built and deployed our application only when they have some changes. You have now a full Continuous Deployment Pipeline running into Github!","title":"Summary"}]}